
## Section 1: Type Annotations in Python

### ✅ Regular Dictionary

```python
movie = {"name": "Avengers Endgame", "year": 2019}
```

This works, but **Python doesn't enforce type checks**. The structure and types of the values aren't validated.

---

### ✅ Typed Dictionary (`TypedDict`)

To enforce structure and type checking in dictionaries, use `TypedDict`:

```python
from typing import TypedDict

class Movie(TypedDict):
    name: str
    year: int

movie = Movie(name="Avengers Endgame", year=2019)
```

This ensures:
- `"name"` is a string
- `"year"` is an integer

---

### ✅ Union

`Union` allows a value to be one of multiple specified types:

```python
from typing import Union

def square(x: Union[int, float]) -> float:
    return x * x

x = 5           # ✅ Valid: integer
x = 1.234       # ✅ Valid: float
x = "Hello"     # ❌ Invalid: string is not allowed
```

Useful when a function parameter can accept more than one type.

---

### ✅ Optional

`Optional` is shorthand for allowing either a specific type or `None`:

```python
from typing import Optional

def nice_message(name: Optional[str]) -> None:
    if name is None:
        print("Hey random person!")
    else:
        print(f"Hi there, {name}!")
```

Here, `name` can either be:
- A `str`
- Or `None`  
Anything else (like `int` or `float`) will be invalid.

---

### ✅ Any

Use `Any` when a variable can be of **any type**, and you don’t want to enforce type safety:

```python
from typing import Any

def print_value(x: Any):
    print(x)

print_value("I pretend to be Batman in the shower sometimes")
```

> ⚠️ Use `Any` sparingly — it disables static type checking.

---

### ✅ Lambda Function

Lambda functions are anonymous functions defined using a single expression:

```python
square = lambda x: x * x

nums = [1, 2, 3, 4]
squares = list(map(lambda x: x * x, nums))
```

This will return: `[1, 4, 9, 16]`



# Key Concepts in AI Workflow Graphs

---

### **State**  
- A shared data structure holding the current information or context of the entire application.  
- Acts like the application’s memory, keeping track of variables and data accessible and modifiable by nodes during execution.  
- **Analogy:** *Whiteboard in a Meeting Room* — Participants (nodes) write and read information on the whiteboard (state) to stay updated and coordinate actions.

---

### **Node**  
- Individual functions or operations performing specific tasks within the graph.  
- Each node receives input and processes it to update the state.  
- **Analogy:** *Assembly Line Stations* — Each station does one job, such as attaching a part, painting, inspecting quality, and so on.

---

### **Graph**  
- The overall structure that maps out how different tasks (nodes) are connected and executed.

---

### **Edges**  
- Connections between nodes that explain the flow of tasks needing execution.  
- **Conditional Edges:** Edges that execute based on specific conditions or logic applied to the current state.

---

### **Start**  
- Entry point marking where the workflow begins.

---

### **End**  
- Marks the completion or termination of the graph.

---

### **Tools**  
- Specialized functions or utilities that nodes can utilize to perform tasks like fetching data from an API.  
- Enhance the capabilities of nodes by adding extra functionalities.  
- **Analogy:** *Tools in a Toolbox* — Like a hammer used to drive nails.

---

### **Tool Node**  
- A node specifically designed to run a tool.  
- **Analogy:** The operator using the tool.

---

### **State Graph**  
- Used to build and compile the graph structure.  
- Manages nodes, edges, and the entire state of the workflow.  
- **Analogy:** The blueprint of the graph.

---

### **Runnable**  
- An executable component to perform a specific task within an AI workflow.  
- Fundamental building block, different from a node because nodes define state, while runnables define execution units.  
- **Analogy:** A Lego brick.

---

### **Message Types**  
- **Human Message:** Represents input from a user.  
- **System Message:** Provides instructions or context to the model.  
- **Function Message:** Represents the result of a function call.  
- **AI Message:** Responses generated by AI models.  
- **Tool Message:** Similar to Function Message, but specific to tool usage.
